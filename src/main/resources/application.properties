server.port=8000
#It will get the config from: http://localhost:8888/currency-exchange/default
#The profile selected is: default
spring.application.name=currency-exchange
spring.config.import=optional:configserver:http://localhost:8888

#H2 configuration (to be deleted in a near future, h2 will be used in application-local.properties).
spring.datasource.url=jdbc:h2:mem:testdb-local

#Reason: By default, data.sql scripts are now run before Hibernate is initialized.
# This aligns the behavior of basic script-based initialization with that of Flyway and Liquibase.
# If you want to use data.sql to populate a schema created by Hibernate,
# set spring.jpa.defer-datasource-initialization to true.
# While mixing database initialization technologies is not recommended,
# this will also allow you to use a schema.sql script to build upon a Hibernate-created schema before it?s populated via data.sql.
spring.jpa.defer-datasource-initialization=true

#This property will allow us to start logging the SQL in log whenever a statement is executed.
spring.h2.console.enabled=true

#JPA
#This property will allow us to start logging the SQL in log whenever a statement is executed.
spring.jpa.show-sql=true

#Eureka
eureka.client.service-url.default-zone=http://localhost:8761/eureka

#Resilience4j

#Retry
#max-attempts (number of tries) before calling a fallbackMethod or through an error.
resilience4j.retry.instances.sample-api.max-attempts=5
#wait-duration between attempts
resilience4j.retry.instances.sample-api.wait-duration=1s
#Each subsequent retry will take longer and longer, and that's what is called ExponentialBackoff.
resilience4j.retry.instances.sample-api.enable-exponential-backoff=true

#Circuit Breaker
# We would want to increase the failureRateThreshold to 90%.
# Only if 90% of the requests fail,
# Then We would want to switch to an OPEN state (since the application will start in CLOSED state.
# So, you can configure things like that in this specific way.
resilience4j.circuitbreaker.instances.default.failure-rate-threshold=90

#there is a Circuit Breaker framework which is available, which is called Resilience4j.

#What if one of the services if down or is slow?
# impact entire chain.

#Questions:
#Can we return a fallback response if a service is down?
#Can we implement a circuit breaker pattern to reduce the load?
#If I see that microserviceX is down, instead of repeatedly hitting it and causing it to go down,
#can I actually return the default response back without even hitting the microservice
#Can we retry requests in case of temporary failures?
#can we retry requests in case of temporary failures? If there is a temporary failure from a microserviceX,
#can I retry it a few times and only when it has failed multiple times, I return a default response back?

#Can we implement something like rate limiting?
#We want to allow only a certain number of calls to a specific microservice in a specific period of time.